# &#x20;AI Evaluation System V2 （涵盖评分规则，关键词，与示例）

## 评分体系速查表

| 维度   | 满分    | 核心评测点          | 常见扣分原因       |
| ---- | ----- | -------------- | ------------ |
| 付费维度 | 50分   | 开篇/付费卡点/看点密度   | 付费点缺失、开篇无吸引力 |
| 剧作维度 | 30分   | 核心推动力/角色/情绪/冲突 | 主线不清晰、人物扁平   |
| 市场维度 | 20分   | 对标/文化禁忌/受众匹配   | 粗俗词超标、受众错位   |
| 改造潜力 | 10分   | 修复成本/预期提升/内核   | 创意问题无法修复     |
| 总分   | 110分  | —              | —            |

## 评级标准

```plain&#x20;text
S+ : 101-110分 → 神作，易改造，强烈推荐
S  : 91-100分  → 精品，直接入选
A+ : 86-90分   → 优质，高改造潜力
A  : 81-85分   → 优质，建议入选
B  : 70-80分   → 合格，修改后入选
C  : <70分     → 不建议入选
```

***

## 一、付费维度（50分）

### 1.1 开篇吸引力（10分）

#### 男主帅气出场（5分）

**评分规则：**

| 得分 | 出场时机               | 必须包含              |
| -- | ------------------ | ----------------- |
| 5分 | Episode 2开头1000字符内 | 视觉标签≥2个 + 人设标签≥1个 |
| 3分 | Episode 2-3        | 视觉或人设标签任一         |
| 1分 | Episode 3之后        | 仅有名字              |
| 0分 | 前3集未出场             | —                 |

**关键词库：**

```python
visual_tags = ['CEO', '总裁', 'suit', 'abs', 'chest', 'handsome',
'帅', '高大', '性感', 'muscular', '英俊']

persona_tags = ['mature', 'composed', 'devoted', 'cold', 'gentle',
'深情', '负责', '霸道', '温柔', '占有欲', '成熟']

# 检测逻辑
ep2_start = episodes[2][:1000]
visual_count = sum(1 for tag in visual_tags if tag in ep2_start)
persona_count = sum(1 for tag in persona_tags if tag in ep2_start)

if '男主角色名' in ep2_start:
    if visual_count >= 2 and persona_count >= 1:
        score = 2
    elif visual_count >= 1 or persona_count >= 1:
        score = 1.5
    else:
        score = 1
else:
    score = 0 if '男主角色名' not in first_3_episodes else 1
```

**示例：**

```plain&#x20;text
✓ 5分案例：
"RYDER (ML, 29, CEO, mature, composed) 赤裸上身，
腹肌性感，缓缓走向床边..."

✗ 0分案例：
Episode 1-3都在讲女主，男主完全没出场
```

#### 女主带故事出场（5分）

**评分规则：**

| 得分 | 标准                 | 检测关键词                       |
| -- | ------------------ | --------------------------- |
| 5分 | 开场即conflict + 动机清晰 | conflict词≥1 + motivation词≥1 |
| 3分 | 有conflict但动机模糊     | conflict词≥1                 |
| 1分 | 静态介绍式出场            | 仅出现女主名字+职业描述                |
| 0分 | 无故事性               | —                           |

**关键词库：**

```python
conflict_keywords = [
'betray', '设计', '陷害', 'drug', '下药', 'trap', '危险',
'scheme', 'plot', 'deceive', '欺骗', 'ambush', '埋伏'
]

motivation_keywords = [
'because', 'for', '为了', '想要', 'plan', '计划',
'need', '必须', 'goal', '目标', 'in order to'
]

# 检测逻辑
ep1_start = episodes[1][:500]  # Episode 1前500字符

has_conflict = any(kw in ep1_start for kw in conflict_keywords)
has_motivation = any(kw in ep1_start for kw in motivation_keywords)

if has_conflict and has_motivation:
    score = 2.5
elif has_conflict:
    score = 1.5
elif '女主角色名' in ep1_start:
    score = 1
else:
    score = 0
```

**示例：**

```plain&#x20;text
✓ 2.5分案例：
"Merissa等待未婚夫Daniel的浪漫之夜(动机)，
却不知他已设计将她下药献给投资人(conflict)"

✗ 1分案例：
"Merissa, 26岁，美丽，在XX公司担任助理"
```

#### 核心矛盾Establish（2分）

**评分规则：**

| 得分   | 标准                | 检测标准            |
| ---- | ----------------- | --------------- |
| 2分   | Episode 1明确不可调和矛盾 | high-stakes词≥3次 |
| 1.5分 | 有矛盾但强度不足          | high-stakes词2次  |
| 1分   | 矛盾模糊              | high-stakes词1次  |
| 0分   | 无矛盾               | 0次              |

**关键词库：**

```python
high_stakes_keywords = [
'betray', '背叛', 'kill', '杀', 'destroy', '毁灭',
'revenge', '复仇', 'life or death', '生死',
'ruin', '毁掉', 'forever', '永远', 'never forgive', '永不原谅'
]

# 检测逻辑
ep1_full = episodes[1]
count = sum(ep1_full.lower().count(kw.lower()) for kw in high_stakes_keywords)

if count >= 3:
    score = 2
elif count >= 2:
    score = 1.5
elif count >= 1:
    score = 1
else:
    score = 0
```

**示例：**

```plain&#x20;text
✓ 2分案例：
"Daniel背叛Merissa(1)，将她献身换投资(2)，
Merissa发誓要复仇(3)，让他一无所有"

✗ 1分案例：
"Daniel和Merissa因误会吵架了"
```

#### 风格精准确立（1.5分）

**评分规则：**

| 得分   | 标准           | 检测标准              |
| ---- | ------------ | ----------------- |
| 1.5分 | 前3集≥2次风格标志场景 | genre关键词≥2类，每类≥1次 |
| 1分   | 1次标志场景       | genre关键词1类        |
| 0.5分 | 风格摇摆         | 多类型混合无主导          |
| 0分   | 无法判断         | 无genre关键词         |

**关键词库：**

```python
genre_keywords = {
'爽剧': [
    'slap face', '打脸', 'expose', '揭露', 'fight back', '反击',
    'luxury entrance', '豪门登场', 'identity reveal', '身份揭露',
    'revenge succeed', '复仇成功'
],
'虐剧': [
    'misunderstand', '误会', 'sacrifice', '牺牲', 'separation', '分离',
    'tears', '哭戏', 'cry', 'painful choice', '痛苦抉择',
    'can\'t be together', '不能在一起'
],
'复仇剧': [
    'revenge', '报复', 'scheme', '计划', 'hidden identity', '隐藏身份',
    'undercover', '卧底', 'payback', '清算'
]
}

# 检测逻辑
first_3_eps = ''.join(episodes[1:4])
genre_scores = {}

for genre, keywords in genre_keywords.items():
    count = sum(first_3_eps.lower().count(kw.lower()) for kw in keywords)
    genre_scores[genre] = count

max_count = max(genre_scores.values())
genres_with_max = [g for g, c in genre_scores.items() if c == max_count]

if max_count >= 2:
    score = 1.5
elif max_count >= 1:
    score = 1
elif len(genres_with_max) > 1:
    score = 0.5  # 风格摇摆
else:
    score = 0
```

**示例：**

```plain&#x20;text
✓ 1.5分案例：
Episode 1: 女主被设计下药(虐)
Episode 3: 女主当众揭露真相，泼红酒打脸(爽)
→ 虐转爽风格明确

✗ 0.5分案例：
Episode 1虐恋、Episode 2搞笑、Episode 3悬疑
→ 观众困惑："这到底是什么类型？"
```

### 1.2 付费卡点精准度（24分）

#### 第一付费点（14分）— 核心重点

##### 步骤1：位置检测（2分）— 基础分

**合理区间：**

* Episode 6-7（早期付费，快速转化）

* Episode 10-12（中期付费，常规）

* Episode 13-15（中后期付费，充分铺垫）

**评分规则：**

| 得分 | 标准                    |
| -- | --------------------- |
| 2分 | PAYWALL在任一区间内（含±2集容差） |
| 0分 | PAYWALL偏离所有区间         |

**检测逻辑：**

```python
def detect_paywall():
    """检测PAYWALL标记"""
    patterns = [r'\[PAYWALL\]', r'\[付费点\]', r'\[PAID\]', r'\[PAY\]']

    for ep_num, content in episodes.items():
        for pattern in patterns:
            if re.search(pattern, content, re.IGNORECASE):
                return ep_num
    return None

def evaluate_position(paywall_ep):
    """评估位置合理性"""
    valid_ranges = [(4, 9), (8, 14), (11, 17)]  # 含±2容差

    for start, end in valid_ranges:
        if start <= paywall_ep <= end:
            return 2
    return 0

# 执行
paywall_pos = detect_paywall()
if paywall_pos:
    position_score = evaluate_position(paywall_pos)
else:
    position_score = 0
    print("⚠️ 警告：未检测到PAYWALL标记")
```

**示例：**

```plain&#x20;text
✓ 2分案例：
50集剧本，PAYWALL在Episode 9
→ 9在(8,14)区间内 ✓

✗ 0分案例：
50集剧本，PAYWALL在Episode 25
→ 偏离所有合理区间 ✗
```

##### 步骤2：前一集精彩度（4分）

**评分规则：**

| 得分 | 标准   | 必须满足           |
| -- | ---- | -------------- |
| 4分 | 三项全满 | 情节密度+情绪高潮+悬念铺垫 |
| 3分 | 满足2项 | 任意两项           |
| 2分 | 满足1项 | 任意一项           |
| 0分 | 都不满足 | —              |

**检测逻辑：**

```python
def evaluate_previous_episode(paywall_ep):
    """评估付费点前一集的精彩度"""
    prev_ep = episodes[paywall_ep - 1]

    # 1. 情节密度
    plot_keywords = [
        'discover', 'reveal', 'expose', 'decide', 'confront',
        '发现', '揭露', '决定', '对峙', '改变', '突破'
    ]
    plot_count = sum(prev_ep.lower().count(kw.lower()) for kw in plot_keywords)
    has_plot = plot_count >= 2

    # 2. 情绪高潮
    emotion_keywords = [
        'cry', 'scream', 'shocked', 'furious', 'breakdown', 'collapse',
        '哭', '尖叫', '震惊', '愤怒', '崩溃', '绝望'
    ]
    emotion_count = sum(prev_ep.lower().count(kw.lower()) for kw in emotion_keywords)
    has_emotion = emotion_count >= 2

    # 3. 悬念铺垫
    foreshadow_keywords = [
        'soon', 'tomorrow', 'will', 'plan', 'wonder', 'V.O.',
        '即将', '明天', '将要', '计划', '好奇', '内心'
    ]
    foreshadow_count = sum(prev_ep.count(kw) for kw in foreshadow_keywords)
    has_foreshadow = foreshadow_count >= 2

    # 计算得分
    satisfied = sum([has_plot, has_emotion, has_foreshadow])
    score_map = {3: 4, 2: 3, 1: 2, 0: 0}
    return score_map[satisfied]
```

**示例：**

```plain&#x20;text
✓ 4分案例（Episode 8，付费点在Episode 9）：
- 情节：Merissa在奢侈品店与Vivian对峙，剪头发 ✓
- 情绪：Merissa愤怒反击，泼酒，高情绪场景 ✓
- 伏笔："明天的慈善晚宴，她能进去吗？V.O." ✓

✗ 0分案例：
Episode 8仅是平淡过渡，无重要情节推进
```

##### 步骤3：Hook强度（5分）— 核心决定因素

**评分规则：**

| 得分 | Hook类型          | 示例              |
| -- | --------------- | --------------- |
| 5分 | 决策型：A or B？影响主线 | "选择：揭露 vs 隐瞒"   |
| 4分 | 危机型：生死攸关        | "刀刺向Merissa..." |
| 3分 | 信息型：真相是什么？      | "她到底是谁？"        |
| 2分 | 情感型：他会回来吗？      | "Ryder会原谅吗？"    |
| 0分 | 无Hook           | 平淡结尾            |

**检测逻辑：**

```python
def evaluate_hook_strength(paywall_ep):
    """评估PAYWALL处的Hook强度"""
    # 提取PAYWALL前后100字符
    paywall_content = episodes[paywall_ep]
    paywall_index = paywall_content.find('[PAYWALL]')

    if paywall_index == -1:
        # 如果没有明确标记，取集末尾
        context = paywall_content[-200:]
    else:
        start = max(0, paywall_index - 100)
        end = min(len(paywall_content), paywall_index + 100)
        context = paywall_content[start:end]

    # 决策型检测
    decision_keywords = [
        'choose', 'decide', 'must', 'either', 'or', 'A or B',
        '选择', '决定', '必须', '要么', '还是'
    ]
    if any(kw in context.lower() for kw in decision_keywords):
        return 5

    # 危机型检测
    crisis_keywords = [
        'danger', 'life or death', 'attack', 'threaten', 'knife', 'gun',
        '危险', '生死', '攻击', '威胁', '刀', '枪'
    ]
    if any(kw in context.lower() for kw in crisis_keywords):
        return 4

    # 信息型检测
    mystery_keywords = [
        'who', 'what', 'secret', 'truth', 'identity', 'really',
        '是谁', '真相', '秘密', '身份', '到底'
    ]
    if any(kw in context.lower() for kw in mystery_keywords):
        return 3

    # 情感型检测
    emotion_keywords = [
        'will he', 'can she', 'would', 'could',
        '会不会', '能否', '是否', '会吗'
    ]
    if any(kw in context.lower() for kw in emotion_keywords):
        return 2

    return 0
```

**示例：**

```plain&#x20;text
✓ 5分案例（决策型）：
"Merissa站在悬崖边。跳下去，一切结束；
回去，面对背叛她的人。她的手在颤抖..."

✓ 4分案例（危机型）：
"Vivian举起刀，刺向Merissa的肚子..."

✓ 3分案例（信息型）：
"Could she be... the Governor's daughter?!"

✗ 0分案例：
"Merissa回家睡觉了。"（无任何悬念）
```

##### 步骤4：后一集吸引力（3分）

**评分规则：**

| 得分 | 标准   | 必须满足           |
| -- | ---- | -------------- |
| 3分 | 三项全满 | 立即解答+新情节+新Hook |
| 2分 | 满足2项 | 任意两项           |
| 1分 | 满足1项 | 任意一项           |
| 0分 | 都不满足 | —              |

**检测逻辑：**

```python
def evaluate_next_episode(paywall_ep):
    """评估付费点后一集的吸引力"""
    next_ep_start = episodes[paywall_ep + 1][:500]  # 前500字符

    # 1. 是否立即解答
    answer_keywords = [
        'reveal', 'announce', 'finally', 'truth is', 'yes', 'no',
        '揭露', '公开', '终于', '真相是', '原来', '确实'
    ]
    has_answer = any(kw in next_ep_start.lower() for kw in answer_keywords)

    # 2. 是否有新情节
    new_plot_keywords = [
        'shocked', 'unexpected', 'suddenly', 'then', 'next',
        '震惊', '没想到', '突然', '接着', '紧接着'
    ]
    has_new_plot = any(kw in next_ep_start.lower() for kw in new_plot_keywords)

    # 3. 是否有新Hook
    new_hook_keywords = [
        'but', 'however', 'what if', 'now', 'still',
        '但是', '然而', '如果', '现在', '不过'
    ]
    has_new_hook = any(kw in next_ep_start for kw in new_hook_keywords)

    # 计算得分
    satisfied = sum([has_answer, has_new_plot, has_new_hook])
    score_map = {3: 3, 2: 2, 1: 1, 0: 0}
    return score_map[satisfied]
```

**示例：**

```plain&#x20;text
✓ 3分案例（Episode 10，付费点在Episode 9）：
开头："Merissa走上台：'我是州长女儿！'(立即解答✓)
全场震惊(新情节✓)，Daniel跪地求饶：
'给我一次机会...'(新Hook✓)"

△ 2分案例：
立即解答+新情节，但无新Hook
→ 观众看完第10集就可能流失

✗ 0分案例：
Episode 10开头拖延，不解答悬念，继续铺垫
→ 观众："骗钱！退费！"
```

#### 第二付费点（10分）

**合理区间：**

| 剧本长度    | 第二付费点位置       | 说明      |
| ------- | ------------- | ------- |
| <30集    | 不需要           | 自动满分10分 |
| 30-50集  | Episode 20-25 | 中段付费    |
| 51-70集  | Episode 30-40 | 中段付费    |
| 71-100集 | Episode 50-60 | 中段付费    |

**评分标准（与第一付费点结构相同，但分值按 VA 定义调整）：**

* 位置检测：2分

* 前一集精彩度：3分

* Hook强度：3分

* 后一集吸引力：2分

**额外要求：Escalation**

Hook必须比第一付费点**升级**（赌注更高）

**检测关键词：**

```python
escalation_keywords = [
'life', '生命', 'everything', '一切', 'forever', '永远',
'lose all', '失去所有', 'no turning back', '没有退路',
'final', '最后', 'ultimate', '终极'
]

# 如果第二付费点Hook中不包含escalation关键词
# → Hook强度最多给1分
```

**示例：**

```plain&#x20;text
第一付费点Hook: "身份即将揭露"
第二付费点Hook: "怀孕真相被发现，孩子生死未卜"
→ Escalation ✓ （从个人身份→孩子生命）

✗ 反例：
第一付费点: "身份揭露"
第二付费点: "前男友求复合"
→ 未升级，赌注更低 ✗
```

### 1.3 免费集单集卡点（7分）

**评分规则：**

抽查 Episode 2, 4, 8, 10 的结尾，每集最高 **1.75 分**

| 得分    | 标准         | 检测标准                         |
| ----- | ---------- | ---------------------------- |
| 1.75分 | 有悬念+有可预测线索 | suspense词≥1 + predictable词≥1 |
| 1分    | 悬念过强或过弱    | 仅一类词                         |
| 0分    | 无卡点        | 无悬念词                         |

**检测逻辑：**

```python
def evaluate_episodic_hooks():
    """评估单集卡点"""
    test_episodes = [2, 4, 8, 10]
    scores = []

    for ep_num in test_episodes:
        if ep_num not in episodes:
            continue

        ep_end = episodes[ep_num][-200:]  # 集末尾200字符

        # 悬念词
        suspense_keywords = [
            'what', 'who', 'why', 'shocked', 'stunned', 'freeze',
            '什么', '谁', '震惊', '呆住', '怎么'
        ]
        has_suspense = any(kw in ep_end.lower() for kw in suspense_keywords)

        # 可预测线索
        predictable_keywords = [
            'will', 'soon', 'next', 'tomorrow', 'plan to',
            '将要', '即将', '明天', '下次', '打算'
        ]
        has_predictable = any(kw in ep_end for kw in predictable_keywords)

        if has_suspense and has_predictable:
            scores.append(1.75)
        elif has_suspense or has_predictable:
            scores.append(1)
        else:
            scores.append(0)

    return min(sum(scores), 7)  # 上限7分
```

**示例：**

```plain&#x20;text
✓ 1.75分案例（Episode 2结尾）：
"Merissa震惊(悬念)。明天，她将揭露真相(可预测)。"
→ 观众："我猜她会揭露，但不确定会发生什么"

✗ 1分案例：
"Merissa震惊。"（仅悬念，无线索，完全不可预测）

✗ 0分案例：
"Merissa回家了。"（无悬念）
```

### 1.4 免费集看点密度（7分）

#### Drama事件频率（2.5分）

**评分规则：**

**关键词库（收窄为生死程度事件）：**

```python
drama_events = [
    # 生死
    'kill', 'death', 'die', '死', '杀', '生死',
    # 背叛（致命级别）
    'betray', '背叛',
    # 伤害（身体危害）
    'drug', 'poison', 'attack', '下药', '中毒', '袭击',
    'kidnap', 'accident', '绑架', '事故', '车祸',
    # 重大转折（生死相关）
    'miscarry', '流产',
    'expose', '揭露', '曝光'
]

# 检测前12集
first_12_eps = ''.join(episodes[1:13])
count = sum(first_12_eps.lower().count(kw.lower()) for kw in drama_events)

ratio = count / 6  # 12集/2
if ratio >= 1:
    score = 2.5
elif count / 4 >= 1:  # 12集/3
    score = 1.5
elif count / 3 >= 1:  # 12集/4
    score = 1
else:
    score = 0
```

**示例：**

```plain&#x20;text
✓ 2.5分案例：
前12集: 下药→袭击→身份揭露→绑架→车祸→中毒
= 6个生死级事件 → 6/6=1 → 2.5分

✗ 1分案例：
前12集仅2个生死级事件 → 2/6=0.33 → 1分
```

#### 动机清晰度（2分）

**评分规则：**

**检测逻辑：**

```python
def evaluate_motivation_clarity():
    """评估动机清晰度"""
    first_5_eps = ''.join(episodes[1:6])

    motivation_keywords = [
        'because', 'for', 'want', 'need', 'goal', 'plan', 'must',
        '因为', '为了', '想要', '需要', '目标', '计划', '必须',
        'revenge', 'protect', 'love', '复仇', '保护', '爱'
    ]

    # 主角动机
    protagonist_mentions = first_5_eps.count('女主角色名')
    protagonist_motivation = sum(1 for kw in motivation_keywords
                                 if kw in first_5_eps)
    protagonist_clear = (protagonist_mentions >= 5 and
                         protagonist_motivation >= 3)

    # 反派动机
    antagonist_mentions = first_5_eps.count('反派角色名')
    antagonist_motivation = sum(1 for kw in motivation_keywords
                                if kw in first_5_eps)
    antagonist_clear = (antagonist_mentions >= 3 and
                        antagonist_motivation >= 2)

    if protagonist_clear and antagonist_clear:
        return 2
    elif protagonist_clear:
        return 1
    else:
        return 0
```

**示例：**

```plain&#x20;text
✓ 2分案例：
主角Merissa: 因为被背叛(动机)，要复仇让前男友后悔 ✓
反派Daniel: 为了拿到投资(动机)，设计Merissa ✓

✗ 0分案例：
反派突然做坏事，不知道为什么
```

#### "大事将至"紧张感（2.5分）

**评分规则：**

**检测逻辑：**

```python
def evaluate_foreshadowing():
    """评估紧张感/伏笔密度"""
    foreshadowing_keywords = [
        'soon', 'will', 'going to', 'plan', 'next',
        '即将', '将要', '准备', '计划', '下一步',
        'V.O.', 'thinking', 'wonder',
        '内心', '想到', '思考', '琢磨'
    ]

    full_script = ''.join(episodes.values())
    count = sum(full_script.count(kw) for kw in foreshadowing_keywords)

    ratio = count / len(episodes)

    if ratio >= 2:
        return 2.5
    elif ratio >= 1:
        return 1.5
    else:
        return 0
```

**示例：**

```plain&#x20;text
✓ 2.5分案例：
50集剧本，V.O.出现45次 + will出现38次 = 83次
83/50 = 1.66/集 → 接近满分

✗ 0分案例：
50集剧本，仅10处伏笔 → 0.2/集 → 0分
```

### 1.5 视觉锤（2分）

**评分规则：**

**关键词库：**

```python
visual_hammer_scenes = {
    'slap': ['slap', 'hit face', '巴掌', '打脸', '扇'],
    'kiss': ['kiss', 'passionate', '吻', '激吻', '亲'],
    'punch_kick': ['punch', 'kick', 'fight', '打', '踢', '揍'],
    'water': ['pour water', 'splash', '泼水', '泼酒', '泼'],
    'kneel': ['kneel', 'kowtow', '下跪', '跪下', '跪地'],
    'proposal': ['propose', 'marry me', 'will you marry', '求婚', '嫁给我'],
    'reveal': ['reveal identity', 'expose', '揭露身份', '曝光', '公开'],
    'luxury': ['luxury car', 'convoy', 'bodyguard', '豪车', '车队', '保镖']
}

# 检测前12集
first_12 = ''.join(episodes[1:13])
first_3 = ''.join(episodes[1:4])

total_scenes = sum(sum(first_12.lower().count(kw.lower()) for kw in keywords)
                   for keywords in visual_hammer_scenes.values())

first_3_scenes = sum(sum(first_3.lower().count(kw.lower()) for kw in keywords)
                     for keywords in visual_hammer_scenes.values())

# 检查分布均匀性
is_balanced = (first_3_scenes / total_scenes <= 0.5) if total_scenes > 0 else True

if total_scenes >= 5 and is_balanced:
    score = 2
elif total_scenes >= 3:
    score = 1.5
elif total_scenes >= 1:
    score = 1
else:
    score = 0
```

**示例：**

```plain&#x20;text
✓ 2分案例：
前12集: slap×3 + kiss×2 + propose×1 + reveal×1 + luxury×1 = 8个
前3集: slap×2 + kiss×1 = 3个
3/8 = 37.5% ≤ 50% ✓ 分布均匀

✗ 1.5分案例：
前12集仅4个场景，且全集中在前3集
```

## 二、剧作维度（30分）

### 2.1 核心推动力单一性（10分）

**评分规则：**

**检测逻辑：**

```python
def evaluate_core_driver():
    """评估核心推动力单一性"""
    full_script = ''.join(episodes.values())

    # 关系线关键词
    relationship_keywords = [
        '男主名', '女主名',
        'love', 'hate', 'marry', 'divorce', 'kiss', 'betray',
        '爱', '恨', '结婚', '离婚', '吻', '背叛', '想念', '嫉妒'
    ]
    rel_count = sum(full_script.lower().count(kw.lower())
                    for kw in relationship_keywords)

    # 次要线索关键词
    subplot_keywords = [
        'company', 'business', 'deal', 'investment', 'project',
        'meeting', 'contract', 'work',
        '公司', '生意', '投资', '项目', '会议', '合同', '工作'
    ]
    subplot_count = sum(full_script.lower().count(kw.lower())
                        for kw in subplot_keywords)

    # 计算占比
    total = rel_count + subplot_count
    if total == 0:
        return 5  # 默认中等分

    rel_percentage = (rel_count / total) * 100

    if rel_percentage >= 80:
        return 10
    elif rel_percentage >= 60:
        return 7
    elif rel_percentage >= 40:
        return 4
    else:
        return 0
```

**示例：**

```plain&#x20;text
✓ 10分案例：
关系词500次，职场词100次
→ 500/600 = 83.3% ✓

△ 7分案例：
关系词400次，职场词200次
→ 400/600 = 66.7% △ (职场线略重)

✗ 0分案例：
关系词200次，职场词800次
→ 20% ✗ (主线不清)
```

***

### 2.2 角色辨识度（10分）

#### 男主辨识度（4分）

**评分规则：**

**标签类型：**

```python
male_tags = {
    '职业': ['CEO', 'president', 'doctor', 'general', '总裁', '医生', '将军', '教授'],
    '外貌': ['handsome', 'abs', 'tall', 'strong', '帅', '腹肌', '高大', '肌肉'],
    '性格': ['cold', 'gentle', 'mature', 'devoted', '冷酷', '温柔', '成熟', '专情'],
    '行为': ['protect', 'dominate', 'spoil', '保护', '霸道', '宠溺', '占有'],
    '台词': ['my woman', 'stay with me', '我的女人', '跟我走', '听我的']
}

# 检测逻辑
full_script = ''.join(episodes.values())
detected_tags = []
detected_types = set()

for tag_type, tags in male_tags.items():
    for tag in tags:
        if tag in full_script:
            detected_tags.append(tag)
            detected_types.add(tag_type)

tag_count = len(detected_tags)
type_count = len(detected_types)

if tag_count >= 4 and type_count >= 3:
    score = 4
elif tag_count >= 2:
    score = 2
else:
    score = 0
```

**示例：**

```plain&#x20;text
✓ 4分案例：
Ryder: CEO(职业) + abs(外貌) + devoted(性格) + protect(行为)
→ 4个标签，4个类型 ✓

✗ 0分案例：
男主仅有名字，无任何标签
```

#### 女主辨识度（6分）

**评分规则：**

**标签类型：**

```python
female_tags = {
    '身份': ['CEO', 'heiress', 'daughter of', '总裁', '千金', '女儿'],
    '外貌': ['beautiful', 'innocent', 'elegant', '美丽', '清纯', '优雅'],
    '性格': ['strong', 'smart', 'decisive', '坚强', '聪明', '果断', '独立'],
    '成长线': ['revenge', 'rise', 'transform', '复仇', '崛起', '蜕变'],
    '行动能力/受众代入': ['fight back', 'take action', 'stand up',
                          '反击', '行动', '站起来', '不再忍受']
}

# 检测逻辑
full_script = ''.join(episodes.values())
detected_tags = []
detected_types = set()

for tag_type, tags in female_tags.items():
    for tag in tags:
        if tag in full_script:
            detected_tags.append(tag)
            detected_types.add(tag_type)

tag_count = len(detected_tags)
type_count = len(detected_types)

if tag_count >= 5 and type_count >= 4:
    score = 6
elif tag_count >= 3 and type_count >= 3:
    score = 4
elif tag_count >= 2:
    score = 2
else:
    score = 0
```

**示例：**

```plain&#x20;text
✓ 6分案例：
Merissa: Governor女儿(身份) + beautiful(外貌) +
decisive(性格) + rise(成长线) + fight back(行动能力)
→ 5个标签，5个维度 ✓

△ 4分案例：
女主有"美丽"+"善良"+"复仇"3个标签
→ 有成长线但行动能力和受众代入不明

✗ 2分案例：
女主仅有"美丽"+"善良"2个标签
```

### 2.3 情绪浓度（6分）

**评分规则：**

**检测逻辑：**

```python
def evaluate_emotion_density():
    """评估情绪浓度"""
    emotion_keywords = [
        # 悲伤
        'cry', 'tears', 'sob', 'weep', '哭', '泪', '抽泣',
        # 愤怒
        'scream', 'shout', 'roar', 'furious', '尖叫', '怒吼', '愤怒',
        # 震惊
        'shocked', 'stunned', 'freeze', 'gasp', '震惊', '呆住', '倒吸',
        # 恐惧
        'tremble', 'shiver', 'panic', 'terrified', '颤抖', '恐慌', '害怕',
        # 痛苦
        'heartbreak', 'pain', 'ache', 'suffer', '心碎', '痛苦', '折磨'
    ]

    full_script = ''.join(episodes.values())
    total_words = len(full_script.split())

    emotion_count = sum(full_script.lower().count(kw.lower())
                        for kw in emotion_keywords)

    density = (emotion_count / total_words) * 100  # 百分比

    if density >= 1.5:
        return 6
    elif density >= 1.0:
        return 4
    elif density >= 0.5:
        return 2
    else:
        return 0
```

**示例：**

```plain&#x20;text
✓ 6分案例：
50,000字剧本，情绪词出现800次
→ 800/50000 = 1.6% ✓

✗ 2分案例：
50,000字剧本，情绪词仅300次
→ 0.6% → 2分
```

### 2.4 冲突/反转密度（4分）

#### 冲突密度（2.5分）

**评分规则：**

**检测逻辑：**

```python
def evaluate_conflict_density():
    """评估冲突密度"""
    conflict_keywords = [
        'slap', 'punch', 'grab', 'push', 'shove', 'kick',
        '打', '抓', '推', '摔', '踢', '扇',
        'argue', 'fight', 'quarrel', 'confront',
        '争吵', '吵架', '对峙', '争执',
        'furious', 'snarl', 'glare', 'threaten',
        '怒视', '咆哮', '瞪', '威胁'
    ]

    full_script = ''.join(episodes.values())
    conflict_count = sum(full_script.lower().count(kw.lower())
                         for kw in conflict_keywords)

    avg_per_ep = conflict_count / len(episodes)

    if avg_per_ep >= 2:
        return 2.5
    elif avg_per_ep >= 1:
        return 1.5
    else:
        return 0.5
```

**示例：**

```plain&#x20;text
✓ 2.5分案例：
50集剧本，冲突词120次
→ 120/50 = 2.4/集 ✓

✗ 0.5分案例：
50集剧本，冲突词30次
→ 0.6/集 ✗
```

#### 反转密度（1.5分）

**评分规则：**

**检测逻辑：**

```python
def evaluate_twist_density():
    """评估反转密度"""
    twist_keywords = [
        'actually', 'truth is', 'in fact', 'realize', 'turn out',
        '原来', '其实', '竟然', '真相', '没想到',
        'shocked', 'stunned', 'never thought',
        '震惊', '万万没想到', '出乎意料',
        'reveal', 'expose', 'discover',
        '揭露', '发现', '揭穿'
    ]

    # 只计算有identity/身份/真相等关键词的major twist
    identity_keywords = ['identity', '身份', 'truth', '真相', 'secret', '秘密']

    full_script = ''.join(episodes.values())

    # 查找twist关键词附近200字符内是否有identity关键词
    major_twist_count = 0
    for twist_kw in twist_keywords:
        indices = [i for i in range(len(full_script))
                   if full_script[i:i+len(twist_kw)].lower() == twist_kw.lower()]

        for idx in indices:
            context = full_script[max(0, idx-200):min(len(full_script), idx+200)]
            if any(id_kw in context for id_kw in identity_keywords):
                major_twist_count += 1
                break  # 避免重复计数

    ratio = major_twist_count / (len(episodes) / 4)

    if ratio >= 1:
        return 1.5
    elif major_twist_count / (len(episodes) / 6) >= 1:
        return 1
    elif major_twist_count / (len(episodes) / 8) >= 1:
        return 0.5
    else:
        return 0
```

**示例：**

```plain&#x20;text
✓ 1.5分案例：
50集剧本，检测到15个major twist
→ 15/(50/4) = 1.2 ✓

✗ 0.5分案例：
50集剧本，仅6个twist
→ 6/(50/8) = 0.96 → 0.5分
```

## 三、市场维度（20分）

### 3.1 爆款对标（5分）

A)自动识别

**评分规则：**

**检测逻辑：**

```python
def identify_mechanism():
    """识别核心story mechanism"""
    full_script = ''.join(episodes.values())

    # 身份设定
    identity_patterns = {
        '隐藏身份': ['hidden identity', 'secret', 'pretend', '隐藏身份', '伪装'],
        '身份反转': ['daughter of', 'heiress', 'CEO', 'actually', '其实是', '真实身份'],
        '双重身份': ['both...and', 'secret life', '白天...晚上', '双重'],
        '重生穿越': ['reborn', 'time travel', 'previous life', '重生', '穿越']
    }

    # 关系设定
    relationship_patterns = {
        '契约关系': ['contract', 'fake', 'pretend', 'deal', '契约', '协议', '假装'],
        '替身替嫁': ['substitute', 'replacement', '替身', '替嫁'],
        '闪婚': ['flash marriage', 'marry stranger', '闪婚', '陌生人结婚']
    }

    # 冲突类型
    conflict_patterns = {
        '复仇': ['revenge', 'betray', 'payback', '复仇', '报复', '背叛'],
        '虐恋': ['misunderstand', 'sacrifice', 'pain', '误会', '牺牲', '虐'],
        '打脸': ['slap face', 'expose', 'prove wrong', '打脸', '揭穿'],
        '逆袭': ['rise', 'transform', 'from zero to hero', '逆袭', '崛起']
    }

    detected_mechanisms = []

    for category in [identity_patterns, relationship_patterns, conflict_patterns]:
        for mechanism, keywords in category.items():
            if sum(1 for kw in keywords if kw in full_script) >= 2:
                detected_mechanisms.append(mechanism)

    mechanism_count = len(detected_mechanisms)

    if mechanism_count >= 3:
        return 5, detected_mechanisms
    elif mechanism_count >= 2:
        return 3, detected_mechanisms
    elif mechanism_count >= 1:
        return 1, detected_mechanisms
    else:
        return 0, []
```

**输出示例：**

```plain&#x20;text
【机制识别结果】5/5分

检测到的核心Mechanism:
├─ 身份设定: 双重身份（州长女儿 + CEO）
├─ 关系设定: 契约婚姻 → 真爱
├─ 核心冲突: 复仇打脸 + 虐恋
└─ 情节机制: 误会一夜情 → 怀孕 → 身份揭露

Mechanism标签:
「霸总灰姑娘 + 双重身份 + 契约转真爱 + 复仇打脸」
```

#### 或 B)3.1.2 数据库验证（人工辅助）— 5分

**评分规则：**

**操作流程：**

```python
# 投资人可选输入
benchmark_data = {
    'title': '闪婚后发现老公是首富',  # 可选
    'release_date': '2024-11',         # 可选
    'ranking': 'Top 5',                # 可选
    'views': '2.3亿'                   # 可选
}

# AI计算相似度
def calculate_similarity(current_mechanisms, benchmark_title):
    """计算mechanism相似度"""
    # 从数据库中获取对标剧本的mechanisms
    benchmark_mechanisms = database.get(benchmark_title, {}).get('mechanisms', [])

    # Jaccard相似度
    intersection = set(current_mechanisms) & set(benchmark_mechanisms)
    union = set(current_mechanisms) | set(benchmark_mechanisms)

    similarity = len(intersection) / len(union) * 100 if union else 0

    return similarity
```

**输出示例（有对标数据）：**

```plain&#x20;text
【数据库验证】5/5分

对标剧目: 《闪婚后发现老公是首富》
上线时间: 2024年11月
平台排名: ReelShort Top 5
播放数据: 2.3亿播放

相似度分析:
├─ 共同元素: 霸总、契约婚姻、身份反转
├─ 差异元素: 当前版本多了「双重身份CEO」
├─ 相似度: 75% ✓

评分: 5/5分
评级: 近6个月Top 10爆款 + 高相似度
```

**输出示例（无对标数据）：**

```plain&#x20;text
【数据库验证】2/5分（默认）

未提供对标剧目数据

默认得分: 2/5分
说明: 仅基于mechanism识别给分

【建议】
若您知道相似爆款剧目，可提供以下信息提升评分：
1. 对标剧本名称
2. 播放数据（可选）
3. 上线时间（可选）
```

### 3.2 文化禁忌规避（5分）

#### Level 1: 语言问题（可修复）

**扣分规则：** 每个粗俗词 -0.05分，上限扣2分

**粗俗词表：**

```python
vulgar_words = {
    '英文': ['damn', 'hell', 'shit', 'fuck', 'bitch', 'bastard',
             'ass', 'asshole', 'dick', 'cock', 'pussy'],
    '中文': ['他妈的', '操', '贱人', '混蛋', '王八蛋', '婊子', '傻逼', '草']
}

# 检测逻辑
full_script = ''.join(episodes.values()).lower()
vulgar_count = sum(full_script.count(word.lower())
                   for words in vulgar_words.values()
                   for word in words)

language_penalty = min(2, vulgar_count * 0.05)
```

#### Level 2: 内容红线（一票否决）

**任何一项触发 → 直接-5分**

### 3.3 本地化梗密度（5分）

**评分规则：**

**示例：**

```plain&#x20;text
✓ 5分案例（北美市场）：
50集剧本，出现:
- Thanksgiving dinner (Episode 12)
- Super Bowl party (Episode 25)
- Halloween costume (Episode 35)
- Prom night回忆 (Episode 18)
- Christmas Eve special (Episode 42)
- 每2集约0.1个 → 3分

✗ 0分案例：
50集剧本，无任何本地化元素
```

### 3.4 受众范围（5分）

#### 3.4.1 题材-受众匹配度（3分）

**评分规则：**

**题材与核心受众：**

```python
genre_audience_map = {
    '复仇打脸剧': {
        'core_audience': '30-45岁女性',
        'reason': '需要人生经历共鸣',
        'inappropriate': ['sorority', 'graduation', 'dorm', '姐妹会', '毕业舞会', '宿舍']
    },
    'Young Adult': {
        'core_audience': '18-28岁',
        'reason': '青春期共鸣',
        'inappropriate': ['mortgage', 'mother-in-law', '房贷', '婆婆', '二胎']
    },
    '霸总爽剧': {
        'core_audience': '25-40岁女性',
        'reason': '成熟恋爱幻想',
        'inappropriate': ['campus', 'school club', '校园', '学生社团']
    },
    '婆媳家斗': {
        'core_audience': '30-50岁已婚女性',
        'reason': '婚姻生活共鸣',
        'inappropriate': ['campus', 'first love', '校园', '初恋']
    }
}
```

**示例：**

```plain&#x20;text
✓ 3分案例：
题材: 霸总爽剧
核心受众: 25-40岁
内容元素: CEO、豪门、职场、契约婚姻
不匹配元素: 0个 ✓

✗ 1分案例：
题材: 复仇打脸剧
核心受众: 30-40岁
内容: 职场复仇+前男友后悔
✗ 不匹配元素: "大学姐妹会聚会"×3处
→ 30-40岁观众："什么鬼？劝退！"
```

#### 3.4.2 受众纯度与跨度（2分）

**评分规则：**

**示例：**

```plain&#x20;text
✓ 2分案例：
核心受众元素(霸总爽剧): 500次
跨度元素(商战): 100次
→ 500/600 = 83.3% + 有跨度 ✓

△ 1.5分案例：
核心受众: 90%，无跨度元素
→ 精准但略窄

✗ 0分案例：
核心受众: 40%，其他60%
→ 四不像，定位混乱
```

## 四、改造潜力（10分加分项）

### 4.1 修复成本评估（3分）

**评分规则：**

**示例：**

```plain&#x20;text
✓ 3分案例：
致命问题: 粗俗词34处
问题类型: 语言问题
修复工时: 2-3小时（Ctrl+F替换）
得分: 3/3分 ✓

✗ 0分案例：
致命问题: 无清晰story mechanism
问题类型: 核心创意问题
修复工时: >10天（需重写）
得分: 0/3分 ✗
```

### 4.2 修复后预期得分（3分）

**评分规则：**

**示例：**

```plain&#x20;text
✓ 3分案例：
当前81分
可修复项:
├─ 文化禁忌: 0→5分 (+5)
├─ 第二付费点: 0→10分 (+10)
└─ 本地化: 3→5分 (+2)

修复后: 81+17=98分
增量: 17分
得分: 3/3分 ✓

✗ 0分案例：
当前85分
可修复项: 仅语言问题+2分
修复后: 87分
增量: 2分 < 5分
得分: 0/3分 ✗
```

### 4.3 故事内核评估（3分）

**评分规则：**

> **注意：** "角色满分"指角色辨识度 10 分（修正后）。

**意义：** 故事内核优秀 = 底子好，值得改造投资

**示例：**

```plain&#x20;text
✓ 3分案例：
├─ 剧作维度: 28/30 = 93.3% ✓
├─ 核心推动力: 8/10分 ✓
└─ 角色辨识度: 10/10分 ✓

得分: 3/3分
结论: 故事底子极好，值得投资改造

✗ 0分案例：
剧作维度: 20/30 = 66.7%
核心推动力: 4/10分
角色辨识度: 6/10分
→ 底子差，不建议投资
```

### 4.4 市场稀缺性（1分）

**评分规则：**

**示例：**

```plain&#x20;text
✓ 1分案例：
当前mechanism:
[双重身份, 契约婚姻, 复仇打脸, 身份揭露, 怀孕twist]

与数据库100个剧本对比:
平均相似度: 45% < 60% ✓

得分: 1/1分
结论: 有一定独特性

✗ 0分案例：
当前mechanism: [霸总, 灰姑娘]
与数据库平均相似度: 85% > 80%
→ 市场同质化严重
```

***

## 底线否决机制（不占分值）

以下任意一项不及格，**不论总分多高，直接降为C级**。这些点在分值体系里无法被其他维度的高分"稀释"掉。

## **总分结构：**

* 付费维度：50分

* 剧作维度：30分（核心推动力10 + 角色辨识度10 + 情绪浓度6 + 冲突反转4）

* 市场维度：20分

* 改造潜力：10分

* **总分：110分**
